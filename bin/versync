#!/usr/bin/env node

/* global require process */

"use strict";

const sync = require("../");
const fs = require("fs");
const { ArgumentParser } = require("argparse");
require("colors");

/* eslint-disable no-console */

const ERROR = "[ERROR] ".bold.red;
const SUCCESS = "[OK] ".bold.green;

const parser = new ArgumentParser({
  addHelp: true,
  description: "Synchronizes version numbers accross package.json, \
component.json and other source files of your choosing.",
});

parser.addArgument(["-b", "--bump"], {
  help: "Bump the version number in package.json, component.json \
and all other specified source files. It can take one of the following \
values: \"major\", \"minor\", \"patch\". Or you can use \"sync\" to \
copy the version numbers from package.json to the other files. Alternatively \
you can specify a custom version that is higher than the current one. If no \
value is specified, it defaults to \"patch\".",
  nargs: "?",
});

parser.addArgument(["-s", "--sources"], {
  help: "Declare the JavaScript files in which the version number \
will be updated. If not explicitly specified, it is read from the package.json \
\"versionedSources\" property. If it's not present in the package.json and \
not explicitly specified, only component.json and package.json will be synced. \
Optional.",
});

parser.addArgument(["-v", "--verify"], {
  help: "Verifies that package.json, component.json and all other \
source files have the same version number and checks if it conforms to the \
semver specification.",
  action: "storeTrue",
});

parser.addArgument(["-a", "--add"], {
  help: "After bumping the version number, run `git add` versioned files.",
  action: "storeTrue",
});

parser.addArgument(["-t", "--tag"], {
  help: "After bumping the version number, commit the changes to package.json, \
component.json and all other specified source files and create a git tag \
with the current version. (Note that using --add with this flag does nothing \
more than using this flag alone.)",
  action: "storeTrue",
});

const argv = parser.parseArgs();

if (argv.tag && !argv.bump) {
  console.log("The option -t is not valid without -b.");
  parser.printHelp();
  process.exit(1);
}

if (argv.add && !argv.bump) {
  console.log("The option -a is not valid without -b.");
  parser.printHelp();
  process.exit(1);
}

if (!(argv.verify || argv.bump)) {
  console.log("Must specify one of -v or -b.");
  parser.printHelp();
  process.exit(1);
}

if (argv.bump === true) {
  argv.bump = "patch";
}

function existsSync(filePath) {
  try {
    fs.statSync(filePath);
    return true;
  }
  catch (ex) {
    return false;
  }
}

if (!existsSync("package.json")) {
  console.log(
    `${ERROR}No package.json found in the current directory, exiting.`);
  process.exit(1);
}

if (argv.sources) {
  argv.sources = argv.sources.split(",");
}

const runner = new sync.Runner(argv);
runner.onMessage((message) => {
  console.log(`${SUCCESS}${message}`);
});

runner.run().catch((err) => {
  console.log(`${ERROR}${err.message}`);
  process.exit(1);
});
