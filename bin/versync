#!/usr/bin/env node

/* global require process */
"use strict";
const sync = require("../");
const fs = require("fs");
const optimist = require("optimist");
require("colors");

/* eslint-disable no-console */

const ERROR = "[ERROR] ".bold.red;
const SUCCESS = "[OK] ".bold.green;

const argv = optimist
    .usage(`Synchronizes version numbers accross package.json, component.json \
and other source files of your choosing.
Usage: ${"versync -s [source list] -b [release type].".bold}`)
      .option("b", {
        alias: "bump",
        describe: `Bump the version number in package.json, component.json \
and all other specified source files. It can take one of the following \
values: ${"major, minor, patch".bold}. Alternatively you can specify a \
custom version that is higher than the current one. If no value is specified, \
it defaults to ${"patch".bold}.`,
      })
      .option("s", {
        alias: "sources",
        describe: "Declare the JavaScript files in which the version number \
will be updated. If not explicitly specified, it is read from the package.json \
\"versionedSources\" property. If it's not present in the package.json and \
not explicitly specified, only component.json and package.json will be synced. \
Optional.",
      })
      .option("v", {
        alias: "verify",
        describe: "Verifies that package.json, component.json and all other \
source files have the same version number and checks if it conforms to the \
semver specification.",
      })
      .option("t", {
        alias: "tag",
        describe: `Bump the version number, commit the changes to package.json, \
component.json and all other specified source files and create a git tag \
with the current version. It can take one of the following values: \
${"major, minor, patch".bold}. Alternatively you can specify a custom version \
that is higher than the current one. If no value is specified, it defaults to \
${"patch".bold}.`,
      })
        .argv;

if (argv.help || (!argv.verify && !argv.bump && !argv.tag)) {
  console.log(`Running ${"versync".bold.green} version \
${sync.version.bold.green}.\n`);
  console.log(optimist.help());
  process.exit(0);
}

if (argv.tag && !argv.bump) {
  argv.bump = argv.tag;
}

if (argv.bump === true) {
  argv.bump = "patch";
}

function existsSync(filePath) {
  try {
    fs.statSync(filePath);
    return true;
  }
  catch (ex) {
    return false;
  }
}

if (!existsSync("package.json")) {
  console.log(
    `${ERROR}No package.json found in the current directory, exiting.`);
  process.exit(1);
}

if (argv.sources) {
  argv.sources = argv.sources.split(",");
}

const runner = new sync.Runner(argv);
runner.onMessage((message) => {
  console.log(`${SUCCESS}${message}`);
});

runner.run().catch((err) => {
  console.log(`${ERROR}${err.message}`);
  process.exit(1);
});
